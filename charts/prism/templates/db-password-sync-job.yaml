# Copyright (c) Ultraviolet
# SPDX-License-Identifier: Apache-2.0

{{- if .Values.externalsecrets.enabled }}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: prism-db-password-sync-cronjob
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}-db-password-sync
    release: {{ .Release.Name }}
spec:
  schedule: "{{ .Values.dbPasswordSync.schedule | default "*/30 * * * *" }}"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 3
      activeDeadlineSeconds: 1800
      template:
        metadata:
          labels:
            app: {{ .Release.Name }}-db-password-sync
            job: db-password-sync
        spec:
          serviceAccountName: db-password-sync-sa
          restartPolicy: Never
          containers:
          - name: password-sync
            image: bitnami/kubectl:latest
            imagePullPolicy: Always
            command:
            - /bin/bash
            - -c
            - |
              set -e
              
              echo "Starting database password synchronization..."
              
              EXTERNAL_SECRETS=(
                "prism-am-certs-external-secret"
                "prism-auth-external-secret"
                "prism-backends-external-secret"
                "prism-billing-external-secret"
                "prism-cvm-billing-external-secret"
                "prism-computations-external-secret"
                "prism-domains-external-secret"
                "prism-spicedb-db-secrets-external-secret"
                "prism-shared-spicedb-external-secret"
                "prism-users-external-secret"
                "prism-pgbouncer-external-secret"
              )
              
              declare -A SECRET_UPDATED=(
                ["prism-am-certs-secrets"]=false
                ["prism-auth-secrets"]=false
                ["prism-backends-secrets"]=false
                ["prism-billing-secrets"]=false
                ["prism-cvm-billing-secrets"]=false
                ["prism-computations-secrets"]=false
                ["prism-domains-secrets"]=false
                ["prism-spicedb-db-secrets"]=false
                ["prism-shared-spicedb-secrets"]=false
                ["prism-users-secrets"]=false
                ["prism-pgbouncer-secrets"]=false
              )
              
              refresh_external_secret() {
                local external_secret_name=$1
                echo "Refreshing ExternalSecret: $external_secret_name"
                
                local target_secret_name
                case "$external_secret_name" in
                  "prism-am-certs-external-secret") target_secret_name="prism-am-certs-secrets" ;;
                  "prism-auth-external-secret") target_secret_name="prism-auth-secrets" ;;
                  "prism-backends-external-secret") target_secret_name="prism-backends-secrets" ;;
                  "prism-billing-external-secret") target_secret_name="prism-billing-secrets" ;;
                  "prism-cvm-billing-external-secret") target_secret_name="prism-cvm-billing-secrets" ;;
                  "prism-computations-external-secret") target_secret_name="prism-computations-secrets" ;;
                  "prism-domains-external-secret") target_secret_name="prism-domains-secrets" ;;
                  "prism-spicedb-db-secrets-external-secret") target_secret_name="prism-spicedb-db-secrets" ;;
                  "prism-shared-spicedb-external-secret") target_secret_name="prism-shared-spicedb-secrets" ;;
                  "prism-users-external-secret") target_secret_name="prism-users-secrets" ;;
                  "prism-pgbouncer-external-secret") target_secret_name="prism-pgbouncer-secrets" ;;
                  *) target_secret_name="unknown" ;;
                esac
                
                local old_version
                old_version=$(kubectl get secret "$target_secret_name" -n {{ .Release.Namespace }} -o jsonpath='{.metadata.resourceVersion}' 2>/dev/null || echo "not-found")
                
                kubectl annotate externalsecret "$external_secret_name" \
                  force-sync="$(date +%s)" \
                  --overwrite \
                  --namespace={{ .Release.Namespace }}

                if [ $? -eq 0 ]; then
                  echo "Successfully triggered refresh for $external_secret_name"
                  
                  sleep 5
                  local new_version
                  new_version=$(kubectl get secret "$target_secret_name" -n {{ .Release.Namespace }} -o jsonpath='{.metadata.resourceVersion}' 2>/dev/null || echo "not-found")
                  
                  if [ "$old_version" != "$new_version" ] && [ "$new_version" != "not-found" ]; then
                    echo "  ‚úÖ Secret $target_secret_name was updated (version: $old_version -> $new_version)"
                    if [ "$target_secret_name" != "unknown" ]; then
                      SECRET_UPDATED["$target_secret_name"]=true
                    fi
                  else
                    echo "  ‚ÑπÔ∏è  Secret $target_secret_name version unchanged"
                  fi
                else
                  echo "Failed to refresh $external_secret_name"
                  return 1
                fi
              }
              
              # Database configuration map
              declare -A DB_CONFIG=(
                ["{{ .Release.Name }}-postgresqlauth"]="prism-auth-secrets:PRISM_AUTH_DB_PASS:{{ .Values.postgresqlauth.username }}:{{ .Values.postgresqlauth.database }}:{{ .Values.postgresqlauth.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlbackends"]="prism-backends-secrets:PRISM_BACKENDS_DB_PASS:{{ .Values.postgresqlbackends.username }}:{{ .Values.postgresqlbackends.database }}:{{ .Values.postgresqlbackends.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlbilling"]="prism-billing-secrets:MG_BILLING_DB_PASS:{{ .Values.postgresqlbilling.username }}:{{ .Values.postgresqlbilling.database }}:{{ .Values.postgresqlbilling.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlcvmbilling"]="prism-cvm-billing-secrets:PRISM_CVM_BILLING_DB_PASS:{{ .Values.postgresqlcvmbilling.username }}:{{ .Values.postgresqlcvmbilling.database }}:{{ .Values.postgresqlcvmbilling.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlcomputations"]="prism-computations-secrets:PRISM_COMPUTATIONS_DB_PASS:{{ .Values.postgresqlcomputations.username }}:{{ .Values.postgresqlcomputations.database }}:{{ .Values.postgresqlcomputations.password | default "" }}"
                ["{{ .Release.Name }}-postgresqldomains"]="prism-domains-secrets:SMQ_DOMAINS_DB_PASS:{{ .Values.postgresqldomains.username }}:{{ .Values.postgresqldomains.database }}:{{ .Values.postgresqldomains.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlspicedb"]="prism-spicedb-db-secrets:PRISM_SPICEDB_DB_PASS:{{ .Values.postgresqlspicedb.username }}:{{ .Values.postgresqlspicedb.database }}:{{ .Values.postgresqlspicedb.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlusers"]="prism-users-secrets:SMQ_USERS_DB_PASS:{{ .Values.postgresqlusers.username }}:{{ .Values.postgresqlusers.database }}:{{ .Values.postgresqlusers.password | default "" }}"
                ["{{ .Release.Name }}-postgresqlamcerts"]="prism-am-certs-secrets:AM_CERTS_DB_PASS:{{ .Values.postgresqlamcerts.username }}:{{ .Values.postgresqlamcerts.database }}:{{ .Values.postgresqlamcerts.password | default "" }}"
              )
              
              POSTGRES_DEPLOYMENTS=(
                "{{ .Release.Name }}-postgresqlauth"
                "{{ .Release.Name }}-postgresqlbackends"
                "{{ .Release.Name }}-postgresqlbilling"
                "{{ .Release.Name }}-postgresqlcvmbilling"
                "{{ .Release.Name }}-postgresqlcomputations"
                "{{ .Release.Name }}-postgresqldomains"
                "{{ .Release.Name }}-postgresqlspicedb"
                "{{ .Release.Name }}-postgresqlusers"
                "{{ .Release.Name }}-postgresqlamcerts"
              )
              
              update_postgres_password() {
                local db_service=$1
                local secret_name=$2
                local password_key=$3
                local db_user=$4
                local db_name=$5
                local hardcoded_password=$6

                echo "Updating password for database: $db_service"

                if ! kubectl get service "$db_service" -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                  echo "  ‚ö†Ô∏è  Service $db_service not found, skipping..."
                  return 0
                fi

                local new_password
                if ! new_password=$(kubectl get secret $secret_name -n {{ .Release.Namespace }} -o jsonpath="{.data.$password_key}" 2>/dev/null | base64 -d); then
                  echo "  ‚ùå Failed to get password from secret $secret_name"
                  return 1
                fi

                if [ -z "$new_password" ]; then
                  echo "  ‚ùå Password is empty in secret $secret_name"
                  return 1
                fi

                local temp_pod="password-updater-$(date +%s)-$RANDOM"
                local temp_manifest="/tmp/pod-manifest-${temp_pod}.yaml"
                cat > "$temp_manifest" <<EOF
              apiVersion: v1
              kind: Pod
              metadata:
                name: $temp_pod
                namespace: {{ .Release.Namespace }}
                labels:
                  app: password-updater
              spec:
                restartPolicy: Never
                containers:
                - name: postgres-client
                  image: postgres:15-alpine
                  command:
                  - /bin/bash
                  - -c
                  - |
                    set -e

                    echo "Connecting to $db_service"

                    # Try connecting with hardcoded password if provided
                    if [ -n "\$HARDCODED_PASSWORD" ] && [ "\$HARDCODED_PASSWORD" != "" ]; then
                      export PGPASSWORD="\$HARDCODED_PASSWORD"
                      if psql -h "$db_service" -U "$db_user" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$HARDCODED_PASSWORD"
                      fi
                    fi

                    # If hardcoded password didn't work, try the new password
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      export PGPASSWORD="\$NEW_PASSWORD"
                      if psql -h "$db_service" -U "$db_user" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$NEW_PASSWORD"
                      fi
                    fi

                    # If still no connection, try old password from secret
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      export PGPASSWORD="\$OLD_PASSWORD"
                      if psql -h "$db_service" -U "$db_user" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$OLD_PASSWORD"
                      fi
                    fi

                    # If no connection method worked, exit with error
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      echo "‚ùå Failed to connect with any available password method"
                      exit 1
                    fi

                    # Update password for the application user
                    export PGPASSWORD="\$CONNECTION_PASSWORD"
                    if ! psql -h "$db_service" -U "$db_user" -d "$db_name" -c "ALTER USER $db_user WITH PASSWORD '\$NEW_PASSWORD';"; then
                      echo "‚ùå Failed to update user password"
                      exit 1
                    fi

                    # Test the new password
                    export PGPASSWORD="\$NEW_PASSWORD"
                    if ! psql -h "$db_service" -U "$db_user" -d "$db_name" -c "SELECT 1;" >/dev/null 2>&1; then
                      echo "‚ùå Password verification failed for user"
                      exit 1
                    fi

                    if [ -n "\$HARDCODED_PASSWORD" ] && [ "\$HARDCODED_PASSWORD" != "" ]; then
                      export PGPASSWORD="\$HARDCODED_PASSWORD"
                      if psql -h "$db_service" -U "postgres" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$HARDCODED_PASSWORD"
                      fi
                    fi

                    # If hardcoded password didn't work, try the new password
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      export PGPASSWORD="\$NEW_PASSWORD"
                      if psql -h "$db_service" -U "postgres" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$NEW_PASSWORD"
                      fi
                    fi

                    # If still no connection, try old password from secret
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      export PGPASSWORD="\$OLD_PASSWORD"
                      if psql -h "$db_service" -U "postgres" -d "$db_name" -c '\q' >/dev/null 2>&1; then
                        CONNECTION_PASSWORD="\$OLD_PASSWORD"
                      fi
                    fi

                    # If no connection method worked, exit with error
                    if [ -z "\$CONNECTION_PASSWORD" ]; then
                      echo "‚ùå Failed to connect with any available password method for admin"
                      exit 1
                    fi

                    export PGPASSWORD="\$CONNECTION_PASSWORD"
                    if ! psql -h "$db_service" -U "postgres" -d "$db_name" -c "ALTER USER postgres WITH PASSWORD '\$NEW_PASSWORD';"; then
                      echo "‚ùå Failed to update admin password"
                      exit 1
                    fi

                    # Test the new password
                    export PGPASSWORD="\$NEW_PASSWORD"
                    if ! psql -h "$db_service" -U "postgres" -d "$db_name" -c "SELECT 1;" >/dev/null 2>&1; then
                      echo "‚ùå Password verification failed for admin"
                      exit 1
                    fi
                    
                    echo "‚úÖ Password updated successfully"
                  env:
                  - name: OLD_PASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: $secret_name
                        key: $password_key
                        optional: true
                  - name: NEW_PASSWORD
                    value: "$new_password"
                  - name: HARDCODED_PASSWORD
                    value: "$hardcoded_password"
              EOF
                
                kubectl apply -f "$temp_manifest"
                rm -f "$temp_manifest"

                echo "  üöÄ Created temporary pod: $temp_pod"

                # Wait for pod to complete
                local max_wait=420
                local wait_time=0
                while [ $wait_time -lt $max_wait ]; do
                  local phase=$(kubectl get pod $temp_pod -n {{ .Release.Namespace }} -o jsonpath='{.status.phase}' 2>/dev/null || echo "")

                  case $phase in
                    "Succeeded")
                      echo "  ‚úÖ Password update completed successfully"
                      kubectl delete pod $temp_pod -n {{ .Release.Namespace }} --ignore-not-found=true
                      return 0
                      ;;
                    "Failed")
                      echo "  ‚ùå Password update failed"
                      echo "  üìã Pod logs:"
                      kubectl logs $temp_pod -n {{ .Release.Namespace }} 2>/dev/null || echo "    No logs available"
                      kubectl delete pod $temp_pod -n {{ .Release.Namespace }} --ignore-not-found=true
                      return 1
                      ;;
                    "Running"|"Pending")
                      if [ $((wait_time % 30)) -eq 0 ]; then
                        echo "  ‚è≥ Waiting for password update... (${wait_time}s/${max_wait}s)"
                      fi
                      ;;
                    *)
                      if [ $((wait_time % 30)) -eq 0 ]; then
                        echo "  ‚è≥ Pod status: $phase (${wait_time}s/${max_wait}s)"
                      fi
                      ;;
                  esac

                  sleep 2
                  wait_time=$((wait_time + 2))
                done

                echo "  ‚è∞ Timeout waiting for password update"
                kubectl logs $temp_pod -n {{ .Release.Namespace }} 2>/dev/null || echo "    No logs available"
                kubectl delete pod $temp_pod -n {{ .Release.Namespace }} --ignore-not-found=true
                return 1
              }
              
              # Step 1: Refresh all External Secrets
              echo "üîÑ Step 1: Refreshing External Secrets..."
              for secret in "${EXTERNAL_SECRETS[@]}"; do
                if kubectl get externalsecret $secret -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                  refresh_external_secret $secret
                else
                  echo "ExternalSecret $secret not found, skipping..."
                fi
              done
              
              sleep 30
              
              update_spicedb_preshared_key() {
                echo "üîë Updating SpiceDB pre-shared key..."
                
                if ! kubectl get secret prism-shared-spicedb-secrets -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                  echo "  ‚ùå SpiceDB pre-shared key secret not found"
                  return 1
                fi
                
                local new_preshared_key
                if ! new_preshared_key=$(kubectl get secret prism-shared-spicedb-secrets -n {{ .Release.Namespace }} -o jsonpath="{.data.PRISM_SPICEDB_PRE_SHARED_KEY}" 2>/dev/null | base64 -d); then
                  echo "  ‚ùå Failed to get pre-shared key from secret"
                  return 1
                fi
                
                if [ -z "$new_preshared_key" ]; then
                  echo "  ‚ùå Pre-shared key is empty"
                  return 1
                fi
                
                if ! kubectl get deployment {{ .Release.Name }}-spicedb -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                  echo "  ‚ö†Ô∏è  SpiceDB deployment not found, skipping..."
                  return 0
                fi
                
                local current_key_hash
                current_key_hash=$(kubectl get deployment {{ .Release.Name }}-spicedb -n {{ .Release.Namespace }} -o jsonpath='{.spec.template.metadata.annotations.preshared-key-hash}' 2>/dev/null || echo "")
                
                local new_key_hash
                new_key_hash=$(echo -n "$new_preshared_key" | sha256sum | cut -d' ' -f1)
                
                if [ "$current_key_hash" = "$new_key_hash" ]; then
                  echo "  ‚úÖ SpiceDB pre-shared key is already up to date"
                  return 0
                fi
                
                kubectl rollout restart deployment/{{ .Release.Name }}-spicedb \
                  -n {{ .Release.Namespace }}
                
                if [ $? -eq 0 ]; then
                  kubectl rollout status deployment/{{ .Release.Name }}-spicedb -n {{ .Release.Namespace }} --timeout=300s >/dev/null 2>&1
                  echo "  ‚úÖ SpiceDB deployment updated successfully"
                  return 0
                else
                  echo "  ‚ùå Failed to update SpiceDB deployment"
                  return 1
                fi
              }
              
              # Step 2: Update passwords in PostgreSQL databases
              echo ""
              echo "üîê Step 2: Updating passwords in PostgreSQL databases..."
              success_count=0
              failure_count=0
              
              for db_service in "${!DB_CONFIG[@]}"; do
                IFS=':' read -r secret_name password_key db_user db_name hardcoded_password <<< "${DB_CONFIG[$db_service]}"
                
                echo ""
                echo "Processing database: $db_service"
                
                if update_postgres_password "$db_service" "$secret_name" "$password_key" "$db_user" "$db_name" "$hardcoded_password"; then
                  success_count=$((success_count + 1))
                  SECRET_UPDATED["$secret_name"]=true
                else
                  failure_count=$((failure_count + 1))
                fi
              done
              
              restart_postgres_databases() {
                echo "üîÑ Restarting PostgreSQL databases..."
                
                local postgres_restart_success=0
                local postgres_restart_failure=0
                
                for postgres_deployment in "${POSTGRES_DEPLOYMENTS[@]}"; do
                  echo ""
                  echo "  üîÑ Restarting PostgreSQL: $postgres_deployment"
                  
                  if kubectl get statefulset $postgres_deployment -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                    if kubectl rollout restart statefulset/$postgres_deployment \
                      -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                      echo "    ‚úÖ Restarted StatefulSet: $postgres_deployment"
                      postgres_restart_success=$((postgres_restart_success + 1))
                    else
                      echo "    ‚ùå Failed to restart StatefulSet $postgres_deployment"
                      postgres_restart_failure=$((postgres_restart_failure + 1))
                    fi
                  else
                    echo "    ‚ö†Ô∏è  PostgreSQL $postgres_deployment not found"
                  fi
                done
                
                echo ""
                echo "  üìä PostgreSQL restart summary:"
                echo "    ‚úÖ Successful restarts: $postgres_restart_success"
                echo "    ‚ùå Failed restarts: $postgres_restart_failure"
                
                return 0
              }
              
              restart_all_pods_with_secrets() {
                echo "üîÑ Finding and restarting all pods that use updated secrets..."
                
                local restart_success_count=0
                local restart_failure_count=0
                
                local updated_secrets=()
                for secret_name in "${!SECRET_UPDATED[@]}"; do
                  if [ "${SECRET_UPDATED[$secret_name]}" = "true" ]; then
                    updated_secrets+=("$secret_name")
                  fi
                done
                
                if [ ${#updated_secrets[@]} -eq 0 ]; then
                  echo "  ‚ÑπÔ∏è  No secrets marked as updated, restarting all application deployments"
                  updated_secrets=(
                    "prism-am-certs-secrets"
                    "prism-auth-secrets"
                    "prism-backends-secrets"
                    "prism-billing-secrets"
                    "prism-cvm-billing-secrets"
                    "prism-computations-secrets"
                    "prism-domains-secrets"
                    "prism-spicedb-db-secrets"
                    "prism-shared-spicedb-secrets"
                    "prism-users-secrets"
                    "prism-ui-secrets"
                    "prism-shared-grpc-server-certs"
                    "prism-shared-grpc-client-certs"
                  )
                fi
                
                local deployments_to_restart=()
                
                local all_deployments
                if ! all_deployments=$(kubectl get deployments -n {{ .Release.Namespace }} -o name 2>/dev/null); then
                  echo "  ‚ùå Failed to get deployments list"
                  return 1
                fi

                while IFS= read -r deployment; do
                  if [ -z "$deployment" ]; then
                    continue
                  fi
                  
                  local deployment_name=${deployment#deployment/}
                  
                  local deployment_spec
                  if ! deployment_spec=$(kubectl get "$deployment" -n {{ .Release.Namespace }} -o yaml 2>/dev/null); then
                    continue
                  fi
                  
                  local uses_updated_secret=false
                  for secret_name in "${updated_secrets[@]}"; do
                    if echo "$deployment_spec" | grep -q "$secret_name"; then
                      uses_updated_secret=true
                      break
                    fi
                  done
                  
                  if [ "$uses_updated_secret" = "true" ]; then
                    deployments_to_restart+=("$deployment_name")
                  fi
                done <<< "$all_deployments"
                
                # Get all rollouts in the namespace
                local all_rollouts
                all_rollouts=$(kubectl get rollout.argoproj.io -n {{ .Release.Namespace }} -o name 2>/dev/null) || true
                
                if [ -n "$all_rollouts" ]; then
                  while IFS= read -r rollout; do
                    if [ -z "$rollout" ]; then
                      continue
                    fi
                    
                    local rollout_name=${rollout#rollout/}
                    local rollout_spec
                    if ! rollout_spec=$(kubectl get "$rollout" -n {{ .Release.Namespace }} -o yaml 2>/dev/null); then
                      continue
                    fi
                    
                    # Check if this rollout uses any of the updated secrets
                    local uses_updated_secret=false
                    for secret_name in "${updated_secrets[@]}"; do
                      if echo "$rollout_spec" | grep -q "$secret_name"; then
                        uses_updated_secret=true
                        break
                      fi
                    done
                    
                    if [ "$uses_updated_secret" = "true" ]; then
                      deployments_to_restart+=("$rollout_name")
                    fi
                  done <<< "$all_rollouts"
                fi
                
                local known_deployments=(
                  "{{ .Release.Name }}-auth"
                  "{{ .Release.Name }}-backends"
                  "{{ .Release.Name }}-billing"
                  "{{ .Release.Name }}-cvm-billing"
                  "{{ .Release.Name }}-computations"
                  "{{ .Release.Name }}-domains"
                  "{{ .Release.Name }}-users"
                  "{{ .Release.Name }}-am-certs"
                  "{{ .Release.Name }}-ui"
                  "{{ .Release.Name }}-spicedb"
                )
                
                for known_dep in "${known_deployments[@]}"; do
                  if [[ ! " ${deployments_to_restart[*]} " =~ " $known_dep " ]]; then
                    deployments_to_restart+=("$known_dep")
                  fi
                done
                
                for deployment in "${deployments_to_restart[@]}"; do
                  echo ""
                  echo "  üîÑ Restarting deployment/rollout: $deployment"
                  
                  if kubectl get rollout "$deployment" -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                    if kubectl patch rollout "$deployment" \
                      -n {{ .Release.Namespace }} \
                      -p "{\"spec\": {\"template\": {\"metadata\": {\"annotations\": {\"restartedAt\": \"$(date +%Y-%m-%dT%H:%M:%S%z)\"}}}}}" \
                      --type=merge >/dev/null 2>&1; then
                      echo "    ‚úÖ Restarted rollout: $deployment"
                      restart_success_count=$((restart_success_count + 1))
                    else
                      echo "    ‚ùå Failed to restart rollout $deployment"
                      restart_failure_count=$((restart_failure_count + 1))
                    fi
                  elif kubectl get deployment "$deployment" -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                    if kubectl rollout restart deployment/"$deployment" \
                      -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                      echo "    ‚úÖ Restarted deployment: $deployment"
                      restart_success_count=$((restart_success_count + 1))
                    else
                      echo "    ‚ùå Failed to restart deployment $deployment"
                      restart_failure_count=$((restart_failure_count + 1))
                    fi
                  else
                    continue
                  fi
                done
                
                echo ""
                echo "  üîÑ Checking StatefulSets for secret usage..."
                
                local all_statefulsets
                if all_statefulsets=$(kubectl get statefulsets -n {{ .Release.Namespace }} -o name 2>/dev/null); then
                  while IFS= read -r statefulset; do
                    if [ -z "$statefulset" ]; then
                      continue
                    fi
                    
                    local sts_name=${statefulset#statefulset/}
                    
                    if [[ "$sts_name" =~ postgresql ]]; then
                      continue
                    fi
                    
                    local sts_spec
                    if ! sts_spec=$(kubectl get "$statefulset" -n {{ .Release.Namespace }} -o yaml 2>/dev/null); then
                      continue
                    fi
                    
                    local uses_updated_secret=false
                    for secret_name in "${updated_secrets[@]}"; do
                      if echo "$sts_spec" | grep -q "$secret_name"; then
                        uses_updated_secret=true
                        break
                      fi
                    done
                    
                    if [ "$uses_updated_secret" = "true" ]; then
                      if kubectl annotate statefulset "$sts_name" \
                        -n {{ .Release.Namespace }} \
                        secrets-updated="$(date -Iseconds)" \
                        restart-reason="updated-secrets" \
                        --overwrite >/dev/null 2>&1; then
                        echo "      ‚úÖ Restarted StatefulSet: $sts_name"
                        restart_success_count=$((restart_success_count + 1))
                      else
                        echo "      ‚ùå Failed to restart StatefulSet $sts_name"
                        restart_failure_count=$((restart_failure_count + 1))
                      fi
                    fi
                  done <<< "$all_statefulsets"
                fi
                
                echo ""
                echo "  üîÑ Checking DaemonSets for secret usage..."
                
                local all_daemonsets
                if all_daemonsets=$(kubectl get daemonsets -n {{ .Release.Namespace }} -o name 2>/dev/null); then
                  while IFS= read -r daemonset; do
                    if [ -z "$daemonset" ]; then
                      continue
                    fi
                    
                    local ds_name=${daemonset#daemonset/}
                    
                    local ds_spec
                    if ! ds_spec=$(kubectl get "$daemonset" -n {{ .Release.Namespace }} -o yaml 2>/dev/null); then
                      continue
                    fi
                    
                    local uses_updated_secret=false
                    for secret_name in "${updated_secrets[@]}"; do
                      if echo "$ds_spec" | grep -q "$secret_name"; then
                        uses_updated_secret=true
                        break
                      fi
                    done
                    
                    if [ "$uses_updated_secret" = "true" ]; then
                      if kubectl patch daemonset "$ds_name" \
                        -n {{ .Release.Namespace }} \
                        -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"secrets-updated\":\"$(date -Iseconds)\",\"restart-reason\":\"updated-secrets\"}}}}}" >/dev/null 2>&1; then
                        echo "      ‚úÖ Restarted DaemonSet: $ds_name"
                        restart_success_count=$((restart_success_count + 1))
                      else
                        echo "      ‚ùå Failed to restart DaemonSet $ds_name"
                        restart_failure_count=$((restart_failure_count + 1))
                      fi
                    fi
                  done <<< "$all_daemonsets"
                fi
                
                if [ $restart_success_count -gt 0 ]; then
                  echo ""
                  echo "  ‚è≥ Waiting for pod restarts to complete..."
                  
                  for deployment in "${deployments_to_restart[@]}"; do
                    if kubectl get rollout "$deployment" -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                      kubectl argo rollouts status "$deployment" -n {{ .Release.Namespace }} --timeout=180s >/dev/null 2>&1 || true
                    elif kubectl get deployment "$deployment" -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                      kubectl rollout status deployment/"$deployment" -n {{ .Release.Namespace }} --timeout=180s >/dev/null 2>&1 || true
                    fi
                  done
                fi
                
                echo ""
                echo "  üìä Pod restart summary:"
                echo "    ‚úÖ Successful restarts: $restart_success_count"
                echo "    ‚ùå Failed restarts: $restart_failure_count"
                
                return 0
              }
              
              # Step 3: Update SpiceDB pre-shared key
              echo ""
              echo "üîë Step 3: Updating SpiceDB pre-shared key..."
              spicedb_update_success=false
              if update_spicedb_preshared_key; then
                spicedb_update_success=true
              else
                echo "‚ö†Ô∏è  SpiceDB pre-shared key update failed"
              fi
              
              # Step 4: Restart PostgreSQL databases
              echo ""
              echo "üîÑ Step 4: Restarting PostgreSQL databases..."
              restart_postgres_databases
              
              sleep 60
              
              # Step 5: Restart all pods with updated secrets
              echo ""
              echo "üîÑ Step 5: Restarting all pods with updated secrets..."
              restart_all_pods_with_secrets
              
              echo ""
              echo "üìä Summary:"
              echo "  ‚úÖ Successful database updates: $success_count"
              echo "  ‚ùå Failed database updates: $failure_count"
              if [ "$spicedb_update_success" = true ]; then
                echo "  üîë SpiceDB pre-shared key: ‚úÖ Updated successfully"
              else
                echo "  üîë SpiceDB pre-shared key: ‚ùå Update failed"
              fi
              
              echo "Database password and key synchronization completed"
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 200m
                memory: 256Mi

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: db-password-sync-sa
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: db-password-sync-role
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
rules:
- apiGroups: ["external-secrets.io"]
  resources: ["externalsecrets"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["create", "get", "list", "watch", "delete"]
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "update", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments/status"]
  verbs: ["get"]
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: ["apps"]
  resources: ["statefulsets/status"]
  verbs: ["get"]
- apiGroups: ["apps"]
  resources: ["daemonsets"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: ["apps"]
  resources: ["daemonsets/status"]
  verbs: ["get"]
- apiGroups: ["argoproj.io"]
  resources: ["rollouts"]
  verbs: ["get", "list", "patch", "update", "watch"]
- apiGroups: ["argoproj.io"]
  resources: ["rollouts/status"]
  verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: db-password-sync-rolebinding
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
subjects:
- kind: ServiceAccount
  name: db-password-sync-sa
  namespace: {{ .Release.Namespace }}
roleRef:
  kind: Role
  name: db-password-sync-role
  apiGroup: rbac.authorization.k8s.io

{{- end }}